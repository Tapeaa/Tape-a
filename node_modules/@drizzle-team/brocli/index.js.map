{"version":3,"sources":["../node_modules/.pnpm/clone@2.1.2/node_modules/clone/clone.js","../node_modules/.pnpm/shell-quote@1.8.1/node_modules/shell-quote/quote.js","../node_modules/.pnpm/shell-quote@1.8.1/node_modules/shell-quote/parse.js","../node_modules/.pnpm/shell-quote@1.8.1/node_modules/shell-quote/index.js","../src/brocli-error.ts","../src/command-core.ts","../src/event-handler.ts","../src/util.ts","../src/option-builder.ts"],"sourcesContent":["var clone = (function() {\n'use strict';\n\nfunction _instanceof(obj, type) {\n  return type != null && obj instanceof type;\n}\n\nvar nativeMap;\ntry {\n  nativeMap = Map;\n} catch(_) {\n  // maybe a reference error because no `Map`. Give it a dummy value that no\n  // value will ever be an instanceof.\n  nativeMap = function() {};\n}\n\nvar nativeSet;\ntry {\n  nativeSet = Set;\n} catch(_) {\n  nativeSet = function() {};\n}\n\nvar nativePromise;\ntry {\n  nativePromise = Promise;\n} catch(_) {\n  nativePromise = function() {};\n}\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/\nfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    includeNonEnumerable = circular.includeNonEnumerable;\n    circular = circular.circular;\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      child = new nativeMap();\n    } else if (_instanceof(parent, nativeSet)) {\n      child = new nativeSet();\n    } else if (_instanceof(parent, nativePromise)) {\n      child = new nativePromise(function (resolve, reject) {\n        parent.then(function(value) {\n          resolve(_clone(value, depth - 1));\n        }, function(err) {\n          reject(_clone(err, depth - 1));\n        });\n      });\n    } else if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      if (Buffer.allocUnsafe) {\n        // Node.js >= 4.5.0\n        child = Buffer.allocUnsafe(parent.length);\n      } else {\n        // Older Node.js versions\n        child = new Buffer(parent.length);\n      }\n      parent.copy(child);\n      return child;\n    } else if (_instanceof(parent, Error)) {\n      child = Object.create(parent);\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      parent.forEach(function(value, key) {\n        var keyChild = _clone(key, depth - 1);\n        var valueChild = _clone(value, depth - 1);\n        child.set(keyChild, valueChild);\n      });\n    }\n    if (_instanceof(parent, nativeSet)) {\n      parent.forEach(function(value) {\n        var entryChild = _clone(value, depth - 1);\n        child.add(entryChild);\n      });\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(parent);\n      for (var i = 0; i < symbols.length; i++) {\n        // Don't need to worry about cloning a symbol because it is a primitive,\n        // like a number or string.\n        var symbol = symbols[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n          continue;\n        }\n        child[symbol] = _clone(parent[symbol], depth - 1);\n        if (!descriptor.enumerable) {\n          Object.defineProperty(child, symbol, {\n            enumerable: false\n          });\n        }\n      }\n    }\n\n    if (includeNonEnumerable) {\n      var allPropertyNames = Object.getOwnPropertyNames(parent);\n      for (var i = 0; i < allPropertyNames.length; i++) {\n        var propertyName = allPropertyNames[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n        if (descriptor && descriptor.enumerable) {\n          continue;\n        }\n        child[propertyName] = _clone(parent[propertyName], depth - 1);\n        Object.defineProperty(child, propertyName, {\n          enumerable: false\n        });\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n}\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n}\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n}\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n}\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n}\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n","'use strict';\n\nmodule.exports = function quote(xs) {\n\treturn xs.map(function (s) {\n\t\tif (s && typeof s === 'object') {\n\t\t\treturn s.op.replace(/(.)/g, '\\\\$1');\n\t\t}\n\t\tif ((/[\"\\s]/).test(s) && !(/'/).test(s)) {\n\t\t\treturn \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n\t\t}\n\t\tif ((/[\"'\\s]/).test(s)) {\n\t\t\treturn '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n\t\t}\n\t\treturn String(s).replace(/([A-Za-z]:)?([#!\"$&'()*,:;<=>?@[\\\\\\]^`{|}])/g, '$1\\\\$2');\n\t}).join(' ');\n};\n","'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n\t'\\\\|\\\\|',\n\t'\\\\&\\\\&',\n\t';;',\n\t'\\\\|\\\\&',\n\t'\\\\<\\\\(',\n\t'\\\\<\\\\<\\\\<',\n\t'>>',\n\t'>\\\\&',\n\t'<\\\\&',\n\t'[&;()|<>]'\n].join('|') + ')';\nvar controlRE = new RegExp('^' + CONTROL + '$');\nvar META = '|&;()<> \\\\t';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\nvar hash = /^#$/;\n\nvar SQ = \"'\";\nvar DQ = '\"';\nvar DS = '$';\n\nvar TOKEN = '';\nvar mult = 0x100000000; // Math.pow(16, 8);\nfor (var i = 0; i < 4; i++) {\n\tTOKEN += (mult * Math.random()).toString(16);\n}\nvar startsWithToken = new RegExp('^' + TOKEN);\n\nfunction matchAll(s, r) {\n\tvar origIndex = r.lastIndex;\n\n\tvar matches = [];\n\tvar matchObj;\n\n\twhile ((matchObj = r.exec(s))) {\n\t\tmatches.push(matchObj);\n\t\tif (r.lastIndex === matchObj.index) {\n\t\t\tr.lastIndex += 1;\n\t\t}\n\t}\n\n\tr.lastIndex = origIndex;\n\n\treturn matches;\n}\n\nfunction getVar(env, pre, key) {\n\tvar r = typeof env === 'function' ? env(key) : env[key];\n\tif (typeof r === 'undefined' && key != '') {\n\t\tr = '';\n\t} else if (typeof r === 'undefined') {\n\t\tr = '$';\n\t}\n\n\tif (typeof r === 'object') {\n\t\treturn pre + TOKEN + JSON.stringify(r) + TOKEN;\n\t}\n\treturn pre + r;\n}\n\nfunction parseInternal(string, env, opts) {\n\tif (!opts) {\n\t\topts = {};\n\t}\n\tvar BS = opts.escape || '\\\\';\n\tvar BAREWORD = '(\\\\' + BS + '[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\n\n\tvar chunker = new RegExp([\n\t\t'(' + CONTROL + ')', // control chars\n\t\t'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')+'\n\t].join('|'), 'g');\n\n\tvar matches = matchAll(string, chunker);\n\n\tif (matches.length === 0) {\n\t\treturn [];\n\t}\n\tif (!env) {\n\t\tenv = {};\n\t}\n\n\tvar commented = false;\n\n\treturn matches.map(function (match) {\n\t\tvar s = match[0];\n\t\tif (!s || commented) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tif (controlRE.test(s)) {\n\t\t\treturn { op: s };\n\t\t}\n\n\t\t// Hand-written scanner/parser for Bash quoting rules:\n\t\t//\n\t\t// 1. inside single quotes, all characters are printed literally.\n\t\t// 2. inside double quotes, all characters are printed literally\n\t\t//    except variables prefixed by '$' and backslashes followed by\n\t\t//    either a double quote or another backslash.\n\t\t// 3. outside of any quotes, backslashes are treated as escape\n\t\t//    characters and not printed (unless they are themselves escaped)\n\t\t// 4. quote context can switch mid-token if there is no whitespace\n\t\t//     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t\t//     \"allonetoken\")\n\t\tvar quote = false;\n\t\tvar esc = false;\n\t\tvar out = '';\n\t\tvar isGlob = false;\n\t\tvar i;\n\n\t\tfunction parseEnvVar() {\n\t\t\ti += 1;\n\t\t\tvar varend;\n\t\t\tvar varname;\n\t\t\tvar char = s.charAt(i);\n\n\t\t\tif (char === '{') {\n\t\t\t\ti += 1;\n\t\t\t\tif (s.charAt(i) === '}') {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i - 2, i + 1));\n\t\t\t\t}\n\t\t\t\tvarend = s.indexOf('}', i);\n\t\t\t\tif (varend < 0) {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i));\n\t\t\t\t}\n\t\t\t\tvarname = s.slice(i, varend);\n\t\t\t\ti = varend;\n\t\t\t} else if ((/[*@#?$!_-]/).test(char)) {\n\t\t\t\tvarname = char;\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvar slicedFromI = s.slice(i);\n\t\t\t\tvarend = slicedFromI.match(/[^\\w\\d_]/);\n\t\t\t\tif (!varend) {\n\t\t\t\t\tvarname = slicedFromI;\n\t\t\t\t\ti = s.length;\n\t\t\t\t} else {\n\t\t\t\t\tvarname = slicedFromI.slice(0, varend.index);\n\t\t\t\t\ti += varend.index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getVar(env, '', varname);\n\t\t}\n\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tvar c = s.charAt(i);\n\t\t\tisGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t\t\tif (esc) {\n\t\t\t\tout += c;\n\t\t\t\tesc = false;\n\t\t\t} else if (quote) {\n\t\t\t\tif (c === quote) {\n\t\t\t\t\tquote = false;\n\t\t\t\t} else if (quote == SQ) {\n\t\t\t\t\tout += c;\n\t\t\t\t} else { // Double quote\n\t\t\t\t\tif (c === BS) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tc = s.charAt(i);\n\t\t\t\t\t\tif (c === DQ || c === BS || c === DS) {\n\t\t\t\t\t\t\tout += c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout += BS + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c === DS) {\n\t\t\t\t\t\tout += parseEnvVar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c === DQ || c === SQ) {\n\t\t\t\tquote = c;\n\t\t\t} else if (controlRE.test(c)) {\n\t\t\t\treturn { op: s };\n\t\t\t} else if (hash.test(c)) {\n\t\t\t\tcommented = true;\n\t\t\t\tvar commentObj = { comment: string.slice(match.index + i + 1) };\n\t\t\t\tif (out.length) {\n\t\t\t\t\treturn [out, commentObj];\n\t\t\t\t}\n\t\t\t\treturn [commentObj];\n\t\t\t} else if (c === BS) {\n\t\t\t\tesc = true;\n\t\t\t} else if (c === DS) {\n\t\t\t\tout += parseEnvVar();\n\t\t\t} else {\n\t\t\t\tout += c;\n\t\t\t}\n\t\t}\n\n\t\tif (isGlob) {\n\t\t\treturn { op: 'glob', pattern: out };\n\t\t}\n\n\t\treturn out;\n\t}).reduce(function (prev, arg) { // finalize parsed arguments\n\t\t// TODO: replace this whole reduce with a concat\n\t\treturn typeof arg === 'undefined' ? prev : prev.concat(arg);\n\t}, []);\n}\n\nmodule.exports = function parse(s, env, opts) {\n\tvar mapped = parseInternal(s, env, opts);\n\tif (typeof env !== 'function') {\n\t\treturn mapped;\n\t}\n\treturn mapped.reduce(function (acc, s) {\n\t\tif (typeof s === 'object') {\n\t\t\treturn acc.concat(s);\n\t\t}\n\t\tvar xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t\tif (xs.length === 1) {\n\t\t\treturn acc.concat(xs[0]);\n\t\t}\n\t\treturn acc.concat(xs.filter(Boolean).map(function (x) {\n\t\t\tif (startsWithToken.test(x)) {\n\t\t\t\treturn JSON.parse(x.split(TOKEN)[1]);\n\t\t\t}\n\t\t\treturn x;\n\t\t}));\n\t}, []);\n};\n","'use strict';\n\nexports.quote = require('./quote');\nexports.parse = require('./parse');\n","import type { BroCliEvent } from './event-handler';\n\n/**\n * Internal error class used to bypass runCli's logging without stack trace\n *\n * Used only for malformed commands and options\n */\nexport class BroCliError extends Error {\n\tconstructor(message: string | undefined, public event?: BroCliEvent) {\n\t\tconst errPrefix = 'BroCli error: ';\n\t\tsuper(message === undefined ? message : `${errPrefix}${message}`);\n\t}\n}\n","import clone from 'clone';\nimport { BroCliError } from './brocli-error';\nimport { defaultEventHandler, type EventHandler, eventHandlerWrapper } from './event-handler';\nimport {\n\ttype GenericBuilderInternals,\n\ttype GenericBuilderInternalsFields,\n\ttype OutputType,\n\ttype ProcessedBuilderConfig,\n\ttype ProcessedOptions,\n\ttype TypeOf,\n} from './option-builder';\nimport { executeOrLog, isInt, shellArgs } from './util';\n\n// Type area\nexport type CommandHandler<\n\tTOpts extends Record<string, GenericBuilderInternals> | undefined =\n\t\t| Record<string, GenericBuilderInternals>\n\t\t| undefined,\n> = (\n\toptions: TOpts extends Record<string, GenericBuilderInternals> ? TypeOf<TOpts> : undefined,\n) => any;\n\nexport type CommandInfo = {\n\tname: string;\n\taliases?: [string, ...string[]];\n\tdesc?: string;\n\tshortDesc?: string;\n\thidden?: boolean;\n\toptions?: Record<string, ProcessedBuilderConfig>;\n\tmetadata?: any;\n\tsubcommands?: CommandsInfo;\n};\n\nexport type CommandsInfo = Record<string, CommandInfo>;\n\nexport type EventType = 'before' | 'after';\n\nexport type BroCliConfig = {\n\tname?: string;\n\tdescription?: string;\n\targSource?: string[];\n\thelp?: string | Function;\n\tversion?: string | Function;\n\tomitKeysOfUndefinedOptions?: boolean;\n\thook?: (event: EventType, command: Command) => any;\n\ttheme?: EventHandler;\n};\n\nexport type GenericCommandHandler = (options?: Record<string, OutputType> | undefined) => any;\n\nexport type RawCommand<\n\tTOpts extends Record<string, GenericBuilderInternals> | undefined =\n\t\t| Record<string, GenericBuilderInternals>\n\t\t| undefined,\n\tTOptsData = TOpts extends Record<string, GenericBuilderInternals> ? TypeOf<TOpts> : undefined,\n\tTTransformed = TOptsData extends undefined ? undefined : TOptsData,\n> = {\n\tname?: string;\n\taliases?: [string, ...string[]];\n\tdesc?: string;\n\tshortDesc?: string;\n\thidden?: boolean;\n\toptions?: TOpts;\n\thelp?: string | Function;\n\ttransform?: (options: TOptsData) => TTransformed;\n\thandler?: (options: Awaited<TTransformed>) => any;\n\tsubcommands?: [Command, ...Command[]];\n\tmetadata?: any;\n};\n\nexport type AnyRawCommand<\n\tTOpts extends Record<string, GenericBuilderInternals> | undefined =\n\t\t| Record<string, GenericBuilderInternals>\n\t\t| undefined,\n> = {\n\tname?: string;\n\taliases?: [string, ...string[]];\n\tdesc?: string;\n\tshortDesc?: string;\n\thidden?: boolean;\n\toptions?: TOpts;\n\thelp?: string | Function;\n\ttransform?: GenericCommandHandler;\n\thandler?: GenericCommandHandler;\n\tsubcommands?: [Command, ...Command[]];\n\tmetadata?: any;\n};\n\nexport type Command<TOptsType = any, TTransformedType = any> = {\n\tname: string;\n\taliases?: [string, ...string[]];\n\tdesc?: string;\n\tshortDesc?: string;\n\thidden?: boolean;\n\toptions?: ProcessedOptions;\n\thelp?: string | Function;\n\ttransform?: GenericCommandHandler;\n\thandler?: GenericCommandHandler;\n\tsubcommands?: [Command, ...Command[]];\n\tparent?: Command;\n\tmetadata?: any;\n};\n\nexport type CommandCandidate = {\n\tdata: string;\n\toriginalIndex: number;\n};\n\nexport type InnerCommandParseRes = {\n\tcommand: Command | undefined;\n\targs: string[];\n};\n\nexport type TestResult<THandlerInput> = {\n\ttype: 'handler';\n\toptions: THandlerInput;\n} | {\n\ttype: 'help' | 'version';\n} | {\n\ttype: 'error';\n\terror: unknown;\n};\n\nconst generatePrefix = (name: string) => name.startsWith('-') ? name : name.length > 1 ? `--${name}` : `-${name}`;\n\nconst validateOptions = <TOptionConfig extends Record<string, GenericBuilderInternals>>(\n\tconfig: TOptionConfig,\n): ProcessedOptions<TOptionConfig> => {\n\tconst cloned = clone(config);\n\n\tconst entries: [string, GenericBuilderInternalsFields][] = [];\n\n\tconst storedNames: [string, ...string[]][] = [];\n\n\tconst cfgEntries = Object.entries(cloned);\n\n\tfor (const [key, value] of cfgEntries) {\n\t\tconst cfg = value._.config;\n\n\t\tif (cfg.name === undefined) cfg.name = key;\n\n\t\tif (cfg.type === 'positional') continue;\n\n\t\tif (cfg.name!.includes('=')) {\n\t\t\tthrow new BroCliError(\n\t\t\t\t`Can't define option '${generatePrefix(cfg.name)}' - option names and aliases cannot contain '='!`,\n\t\t\t);\n\t\t}\n\n\t\tfor (const alias of cfg.aliases) {\n\t\t\tif (alias.includes('=')) {\n\t\t\t\tthrow new BroCliError(\n\t\t\t\t\t`Can't define option '${generatePrefix(cfg.name)}' - option names and aliases cannot contain '='!`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tcfg.name = generatePrefix(cfg.name);\n\n\t\tcfg.aliases = cfg.aliases.map((a) => generatePrefix(a));\n\t}\n\n\tfor (const [key, value] of cfgEntries) {\n\t\tconst cfg = value._.config;\n\n\t\tif (cfg.type === 'positional') {\n\t\t\tentries.push([key, { config: cfg, $output: undefined as any }]);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst reservedNames = ['--help', '-h', '--version', '-v'];\n\n\t\tconst allNames = [cfg.name, ...cfg.aliases];\n\n\t\tfor (const name of allNames) {\n\t\t\tconst match = reservedNames.find((n) => n === name);\n\t\t\tif (match) throw new BroCliError(`Can't define option '${cfg.name}' - name '${match}' is reserved!`);\n\t\t}\n\n\t\tfor (const storage of storedNames) {\n\t\t\tconst nameOccupier = storage.find((e) => e === cfg.name);\n\n\t\t\tif (!nameOccupier) continue;\n\n\t\t\tthrow new BroCliError(\n\t\t\t\t`Can't define option '${cfg.name}' - name is already in use by option '${storage[0]}'!`,\n\t\t\t);\n\t\t}\n\n\t\tfor (const alias of cfg.aliases) {\n\t\t\tfor (const storage of storedNames) {\n\t\t\t\tconst nameOccupier = storage.find((e) => e === alias);\n\n\t\t\t\tif (!nameOccupier) continue;\n\n\t\t\t\tthrow new BroCliError(\n\t\t\t\t\t`Can't define option '${cfg.name}' - alias '${alias}' is already in use by option '${storage[0]}'!`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst currentNames = [cfg.name!, ...cfg.aliases] as [string, ...string[]];\n\n\t\tstoredNames.push(currentNames);\n\n\t\tcurrentNames.forEach((name, idx) => {\n\t\t\tif (currentNames.findIndex((e) => e === name) === idx) return;\n\n\t\t\tthrow new BroCliError(\n\t\t\t\t`Can't define option '${cfg.name}' - duplicate alias '${name}'!`,\n\t\t\t);\n\t\t});\n\n\t\tentries.push([key, { config: cfg, $output: undefined as any }]);\n\t}\n\n\treturn Object.fromEntries(entries) as ProcessedOptions<any>;\n};\n\nconst assignParent = (parent: Command, subcommands: Command[]) =>\n\tsubcommands.forEach((e) => {\n\t\te.